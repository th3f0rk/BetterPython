# BetterPython Edge Case Tests
# The Singularity - Release v1.0.0
# Tests boundary conditions and edge cases

def test_empty_structures() -> int:
    print("Testing empty structures...")

    # Empty string
    let empty_str: str = ""
    if len(empty_str) != 0:
        print("FAIL: empty string length")
        return 1

    # Array that becomes empty after pop
    let arr: [int] = [1]
    let val: int = array_pop(arr)
    if array_len(arr) != 0:
        print("FAIL: popped to empty array")
        return 1

    # Push to now-empty array
    array_push(arr, 42)
    if array_len(arr) != 1:
        print("FAIL: push to empty")
        return 1

    print("  Empty structures: PASS")
    return 0

def test_large_numbers() -> int:
    print("Testing large numbers...")

    # Large integers
    let big: int = 9223372036854775807
    let neg_big: int = -9223372036854775807

    if big <= 0:
        print("FAIL: large positive")
        return 1

    if neg_big >= 0:
        print("FAIL: large negative")
        return 1

    # Large floats
    let big_f: float = 1.7976931348623157e308
    let small_f: float = 2.2250738585072014e-308

    if big_f <= 0.0:
        print("FAIL: large float")
        return 1

    print("  Large numbers: PASS")
    return 0

def test_zero_division() -> int:
    print("Testing zero division...")

    # Float division by zero should give infinity
    let inf: float = 1.0 / 0.0
    if not is_inf(inf):
        print("FAIL: float division by zero")
        return 1

    # Zero divided by zero should give NaN
    let nan_val: float = 0.0 / 0.0
    if not is_nan(nan_val):
        print("FAIL: zero divided by zero")
        return 1

    print("  Zero division: PASS")
    return 0

def test_string_edge_cases() -> int:
    print("Testing string edge cases...")

    # Single character
    let single: str = "a"
    if len(single) != 1:
        print("FAIL: single char string")
        return 1

    if str_reverse(single) != "a":
        print("FAIL: reverse single char")
        return 1

    # Unicode (if supported)
    let unicode_str: str = "hello"
    if len(unicode_str) != 5:
        print("FAIL: unicode string length")
        return 1

    # String with spaces
    let spaced: str = "  hello  world  "
    let trimmed: str = str_trim(spaced)
    if trimmed != "hello  world":
        print("FAIL: trim with internal spaces")
        return 1

    # Empty substring search
    if not str_contains("hello", ""):
        print("FAIL: contains empty string")
        return 1

    print("  String edge cases: PASS")
    return 0

def test_array_edge_cases() -> int:
    print("Testing array edge cases...")

    # Single element array
    let single: [int] = [42]
    if array_len(single) != 1:
        print("FAIL: single element array")
        return 1

    if single[0] != 42:
        print("FAIL: access single element")
        return 1

    # Pop last element
    let last: int = array_pop(single)
    if last != 42:
        print("FAIL: pop single element")
        return 1
    if array_len(single) != 0:
        print("FAIL: array now empty")
        return 1

    # Push to empty
    array_push(single, 100)
    if array_len(single) != 1:
        print("FAIL: push to empty")
        return 1

    print("  Array edge cases: PASS")
    return 0

def test_loop_edge_cases() -> int:
    print("Testing loop edge cases...")

    # Zero iterations
    let count: int = 0
    for idx1 in range(0, 0):
        count = count + 1
    if count != 0:
        print("FAIL: zero iteration for loop")
        return 1

    # Single iteration
    count = 0
    for idx2 in range(0, 1):
        count = count + 1
    if count != 1:
        print("FAIL: single iteration for loop")
        return 1

    # While false condition
    count = 0
    while false:
        count = count + 1
    if count != 0:
        print("FAIL: while false")
        return 1

    # Nested loops with break
    let outer_count: int = 0
    let inner_count: int = 0
    for outer in range(0, 5):
        outer_count = outer_count + 1
        for inner in range(0, 5):
            if inner == 2:
                break
            inner_count = inner_count + 1
    if outer_count != 5:
        print("FAIL: nested outer count")
        return 1
    if inner_count != 10:
        print("FAIL: nested inner count with break")
        return 1

    print("  Loop edge cases: PASS")
    return 0

def test_comparison_edge_cases() -> int:
    print("Testing comparison edge cases...")

    # Zero comparisons
    if not (0 == 0):
        print("FAIL: zero equality")
        return 1

    if 0 != 0:
        print("FAIL: zero inequality")
        return 1

    # Negative comparisons
    if not (-1 < 0):
        print("FAIL: negative less than zero")
        return 1

    if not (0 > -1):
        print("FAIL: zero greater than negative")
        return 1

    # Float comparisons near zero
    let small: float = 0.0000001
    let smaller: float = 0.00000001
    if not (small > smaller):
        print("FAIL: small float comparison")
        return 1

    # String comparisons
    if not ("a" == "a"):
        print("FAIL: string equality")
        return 1

    if "a" == "b":
        print("FAIL: string inequality")
        return 1

    print("  Comparison edge cases: PASS")
    return 0

def deeply_nested(n: int) -> int:
    if n <= 0:
        return 0
    return 1 + deeply_nested(n - 1)

def test_recursion_depth() -> int:
    print("Testing recursion depth...")

    # Test moderate recursion
    let result: int = deeply_nested(100)
    if result != 100:
        print("FAIL: moderate recursion")
        return 1

    print("  Recursion depth: PASS")
    return 0

def test_assignment_expressions() -> int:
    print("Testing assignment expressions...")

    # Chain of assignments
    let a: int = 1
    let b: int = 2
    let c: int = 3

    a = b
    b = c
    c = a

    if a != 2:
        print("FAIL: assignment chain a")
        return 1
    if b != 3:
        print("FAIL: assignment chain b")
        return 1
    if c != 2:
        print("FAIL: assignment chain c")
        return 1

    # Self-referential assignment
    let x: int = 10
    x = x + 5
    x = x * 2
    if x != 30:
        print("FAIL: self-referential assignment")
        return 1

    print("  Assignment expressions: PASS")
    return 0

def main() -> int:
    print("========================================")
    print("BetterPython Edge Case Tests")
    print("The Singularity - v1.0.0")
    print("========================================")
    print("")

    let failures: int = 0

    failures = failures + test_empty_structures()
    failures = failures + test_large_numbers()
    failures = failures + test_zero_division()
    failures = failures + test_string_edge_cases()
    failures = failures + test_array_edge_cases()
    failures = failures + test_loop_edge_cases()
    failures = failures + test_comparison_edge_cases()
    failures = failures + test_recursion_depth()
    failures = failures + test_assignment_expressions()

    print("")
    print("========================================")
    if failures == 0:
        print("ALL EDGE CASE TESTS PASSED!")
    else:
        print("FAILURES:", failures)
    print("========================================")

    return failures
