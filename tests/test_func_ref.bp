# Test: Function references (&func) and indirect calls

def add(a: int, b: int) -> int:
    return a + b

def multiply(a: int, b: int) -> int:
    return a * b

def greet(name: str) -> str:
    return "Hello " + name

def square(x: int) -> int:
    return x * x

def test_basic_func_ref() -> int:
    # Create a function reference and call through it
    let f: fn(int, int) -> int = &add
    let result: int = f(3, 4)
    if result == 7:
        print("PASS basic func ref call")
    else:
        print("FAIL basic func ref call")
        return 1
    return 0

def test_func_ref_multiply() -> int:
    # Create a separate function reference to multiply
    let f: fn(int, int) -> int = &multiply
    let result: int = f(10, 20)
    if result == 200:
        print("PASS func ref multiply")
    else:
        print("FAIL func ref multiply")
        return 1
    return 0

def test_func_ref_str_return() -> int:
    # Function reference with string return type
    let g: fn(str) -> str = &greet
    let msg: str = g("World")
    if msg == "Hello World":
        print("PASS func ref str return")
    else:
        print("FAIL func ref str return")
        return 1
    return 0

def test_func_ref_typeof() -> int:
    # typeof on function reference
    let f: fn(int, int) -> int = &add
    let t: str = typeof(f)
    if t == "func":
        print("PASS func ref typeof")
    else:
        print("FAIL func ref typeof got " + t)
        return 1
    return 0

def test_func_ref_single_arg() -> int:
    # Function reference with single argument
    let sq: fn(int) -> int = &square
    let result: int = sq(5)
    if result == 25:
        print("PASS func ref single arg")
    else:
        print("FAIL func ref single arg")
        return 1
    return 0

def main() -> int:
    test_basic_func_ref()
    test_func_ref_multiply()
    test_func_ref_str_return()
    test_func_ref_typeof()
    test_func_ref_single_arg()
    print("PASS")
    return 0
